set cut_paste_input [stack 0]
version 14.0 v1
push $cut_paste_input
Group {
 name DRT_CAM1
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 selected true
 xpos 88
 ypos -436
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 primaries_in AP1-ACES
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {6 monochrome t "Output monochrome image" +STARTLINE}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply chroma compression" t "Applies the chroma compression step.  If this checkbox alone is checked the applies only the scaling step of chroma compression, but not the in-gamiut compression or the saturation." +STARTLINE}
 applyChromaCompression true
 addUserKnob {6 applyInGamutExpansion l "apply in gamut expansion" t "Expands colorfulness to increase saturation" +STARTLINE}
 applyInGamutExpansion true
 addUserKnob {6 applyInGamutCompression l "apply in gamut compression" +STARTLINE}
 applyInGamutCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.5 4.5 1.1}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom Custom2 None "" "" "" "" ""}}
 et Custom
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {6 iterativeGamutCompressor -STARTLINE}
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit sRGB/Rec.709-D65
 addUserKnob {4 primaries_reach l "reach primaries" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "Spectral Locus" ""}}
 primaries_reach "Spectral Locus"
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.75
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 4.5
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.75 1.2 1.6 1.2}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps 0.7
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {6 reachCompressMode l "Reach Compression Mode" +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.2 1.4 {compressionFuncParamsR.g} 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {{compressionFuncParamsR.r} 1.21 {compressionFuncParamsY.g} 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {{compressionFuncParamsR.r} 1.3 {compressionFuncParamsG.g} 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {{compressionFuncParamsR.r} 1.9 {compressionFuncParamsC.g} 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {{compressionFuncParamsR.r} 1.2 {compressionFuncParamsB.g} 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {{compressionFuncParamsR.r} 1.23 {compressionFuncParamsM.g} 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out BT.1886
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out sRGB/Rec.709-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile "C:/Users/Pekka Riikonen/ACESLooks/Nuke/output-transforms-dev/display-transforms/nuke/CAM_DRT_v042.blink"
  recompileCount 2967
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise 5d564c5a7430aa0e2697a601181095a8ca02edbe10dadfdb01f74760d99d352d 2 \"src\" Read Point \"dst\" Write Point 79 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"applyInGamutExpansion\" Bool 1 AA== \"applyInGamutCompression\" Bool 1 AA== \"monochrome\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"primariesReach\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Reachcompressmode\" Bool 1 AA== \"Locuscompressmode\" Bool 1 AA== \"iterativeGamutCompressor\" Bool 1 AA== \"iterativeGamutCompressorIterations\" Int 1 AAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 79 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"applyInGamutExpansion\" 1 1 \"applyInGamutCompression\" 1 1 \"monochrome\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"primariesReach\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"Reachcompressmode\" 1 1 \"Locuscompressmode\" 1 1 \"iterativeGamutCompressor\" 1 1 \"iterativeGamutCompressorIterations\" 1 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 59 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"ccParams\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"el\" Float 1 1 AAAAAA== \"ef\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"toe\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_reach\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_reach\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"limitMmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTableUnsortedAP1\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTableAP1\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTableReach\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LocusLimitMTable\" Float 1 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n//   Image<eRead, eAccessPoint, eEdgeClamped> extra; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n    bool applyInGamutExpansion;\n    bool applyInGamutCompression;\n    bool monochrome;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n    // Primaries of the Gamut reached by the gamut compressor\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    // 6: Spectral Locus\n    int primariesReach;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n    bool Reachcompressmode;\n    bool Locuscompressmode;\n    bool iterativeGamutCompressor;\n    int iterativeGamutCompressorIterations;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float3 ccParams;\n    float el;\n    float ef;\n    float nJ_exp;     // Tonescale based J exponent\n    float toe;        // Shadow compression\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_reach;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_reach;\n    float3x3 RGB_to_XYZ_output;\n\n    float3x3 AP1_to_XYZ;\n    float3x3 XYZ_to_AP1;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // the maximum colorfulness value of the limiting gamut\n    float limitMmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 gamutCuspTableUnsortedAP1\[360];\n    float3 gamutCuspTableAP1\[360];\n    float3 gamutCuspTableReach\[360];\n    float3 cgamutCuspTable\[360];\n    float LocusLimitMTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n\n    // switch to treat incoming data as luminanceXYZ when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      luminanceXYZ = JMh;\n    \}\n\n\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    // return luminanceRGB when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      return luminanceRGB;\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n    // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n    float3 reach_RGB_to_JMh(float3 RGB)\n    \{\n      float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n      float3 XYZ = vector_dot(RGB_to_XYZ_reach, luminanceRGB);\n      float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      return JMh;\n    \}\n\n  // convert linear RGB values with the AP1 primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 AP1_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(AP1_to_XYZ, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ); // this seems wrong, should be XYZ_to_RGB_limit?\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n    // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the reach primaries\n    float3 JMh_to_reach_RGB(float3 JMh)\n    \{\n        float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n        float3 luminanceRGB = vector_dot(XYZ_to_RGB_reach, luminanceXYZ);\n        float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n        return RGB;\n    \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n    float2 cuspFromTableAP1(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTableAP1\[0].z )\n    \{\n      lo = gamutCuspTableAP1\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTableAP1\[0];\n    \}\n    else if( h >= gamutCuspTableAP1\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTableAP1\[gamutCuspTableSize-1];\n      hi = gamutCuspTableAP1\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTableAP1\[i].z )\n        \{\n          lo = gamutCuspTableAP1\[i-1];\n          hi = gamutCuspTableAP1\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n\n  float2 cuspFromTableLocus(float h)\n  \{\n\n    float cuspJ = 69;\n    float cuspM = LocusLimitMTable\[int(h)];\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n     float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n     float h = max(0.0f, f * f / (f + daniele_t_1));\n     return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n    return f;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n    // Custom2 https://www.desmos.com/calculator/rsbs41nnnm\n    else if (cc_et == 3)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.53f * cos(hr) +\n             -0.13f * cos(hr2) +\n             -0.13f * cos(hr3) +\n             -1.00f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              2.6f) * 0.48f;\n    \}\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k2 = max(k2, 0.002f);\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // Return multiplier to compress noise\n  float compress_noise(float x)\n  \{\n    float f = pow(x, 1.5f);\n    return f / (f + toe);\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white, and from\n  // achromatic outward to purer colors.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //\n  float chromaCompression(float3 JMh, float origJ, float linear, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float snJ = max(0.0f, 1.0f - nJ);\n    float scaling = pow(JMh.x / origJ, nJ_exp);\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float shd = compress_noise(nJ);\n\n    if (!invert)\n    \{\n      M *= scaling;\n      if (applyInGamutCompression)\n      \{\n        M /= Mcusp;\n        if (applyInGamutExpansion)\n          M = compress_range(M, nJ * el, snJ * ef, max(0.1f, nJ), 1);\n        M = compress_range(M, nJ * ccParams.x, nJ * ccParams.y, snJ * lerp(1.0f, ccParams.z, nJ), 0);\n        M *= Mcusp;\n        M *= shd;\n      \}\n    \}\n    else\n    \{\n      if (applyInGamutCompression)\n      \{\n        M /= shd;\n        M /= Mcusp;\n        M = compress_range(M, nJ * ccParams.x, nJ * ccParams.y, snJ * lerp(1.0f, ccParams.z, nJ), 1);\n        if (applyInGamutExpansion)\n          M = compress_range(M, nJ * el, snJ * ef, max(0.1f, nJ), 0);\n        M *= Mcusp;\n      \}\n      M /= scaling;\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6 || diagnosticMode == 100)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n      luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(tonemappedJMh, inputJMh.x, linear, 0);\n    \}\n\n    if (monochrome)\n    \{\n      outputJMh.y = 0.0f;\n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, linear, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y *= 1.0f + 0.14f * s;\n    cusp.x *= 1.0f + 0.07f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n  float3 getLocusBoundry(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float2 cuspLocus = cuspFromTableLocus(h);\n    float cuspTarget100 = cuspLocus.y;\n    // 0.86 has been eyeballed to match the locus in Nuke\n    float cuspTarget = cuspTarget100 * pow((Jmh.x/100.0f),0.86f);\n    float difference =  cuspLocus.y / cuspTarget;\n    return float3(Jmh.x,cuspTarget,Jmh.z);\n  \}\n\nfloat3 getReachBoundry(float3 Jmh)\n\{\n    float h = Jmh.z;\n    \n    // float2 cuspReach = cuspFromTableLocus(h);\n    float reachMaxM = gamutCuspTableReach\[int(h)].x; // at a J of limitJmax\n    // float cuspTarget100 = reachMaxM;\n    // 0.86 has been eyeballed to match the locus in Nuke\n    float cuspTarget = reachMaxM * pow((Jmh.x/limitJmax),0.86f);\n    // float cuspTarget = reachMaxM * pow((limitJmax*Jmh.x),0.86f);\n    // float difference =  reachMaxM / cuspTarget;\n    return float3(Jmh.x,cuspTarget,Jmh.z);\n  \}\n\n\n  float4 getCompressionFuncParams(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float angleR = 20.0f;\n    float angleY = 102.0f;\n    float angleG = 146.0f;\n    float angleC = 193.0f;\n    float angleB = 259.0f;\n    float angleM = 342.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if(Reachcompressmode)\n    \{ \n        if(primariesReach < 6) // All of the primary based reach values\n        \{\n            // use primary based reach\n            float locusMax = getReachBoundry(Jmh).y;\n            float difference =  locusMax / Jmh.y;\n            return float4(compressionFuncParams.x,difference,difference,compressionFuncParams.w);\n        \}\n        else\n        \{\n            // use locus based reach\n            float locusMax = getLocusBoundry(Jmh).y;\n            float difference =  locusMax / Jmh.y;\n            return float4(compressionFuncParams.x,difference,difference,compressionFuncParams.w);\n        \}\n    \}\n        \n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    if (iterativeGamutCompressor)\n    \{\n        return compressGamutIterative(  JMh,  invert,  JMh.x );\n    \}\n\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    // float2 project_to = float2(project_from.x, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n    // float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_from, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMh.x,JMboundary.y,JMh.z));\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n//      JMcompressed = float2(JMh.x,v*JMboundary.y);\n    \}\n\n    // Diagnostic outputs\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 18)\n    \{\n      // return float3(interpolatedCompressionFuncParams.y, interpolatedCompressionFuncParams.z, JMh.z);\n      return float3(JMh.x, JMboundary.y, JMh.z);\n    \}\n    // actual output\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  float3 compressGamutIterative( float3 inputJMh, int invert, float distanceGainCalcJ )\n  \{\n    if( ! applyGamutCompression )\n    \{\n      return inputJMh;\n    \}\n\n    float sstsMidJ = XYZ_to_JMh( refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    float2 JMinput = float2(inputJMh.x, inputJMh.y);\n    float2 JMcusp = cuspFromTable( inputJMh.z);\n\n    float focusJ = lerp(JMcusp.x, sstsMidJ, cuspMidBlend);\n    float focusDistanceGain = 1.0f;\n\n    if( distanceGainCalcJ > focusJ)\n    \{\n      focusDistanceGain = (limitJmax - focusJ) / max(0.0001f, (limitJmax - min(limitJmax, distanceGainCalcJ)));\n    \}\n    else\n    \{\n      focusDistanceGain = (focusJ)             / max(0.0001f, distanceGainCalcJ); \n    \}\n\n    float focusAdjust = max(max(0.01f, 0.4f), min(1.0f, 0.7f) - (distanceGainCalcJ / limitJmax));\n    // float2 JMfocus = float2( focusJ, -JMcusp.y * focusAdjust * focusDistanceGain );\n    float2 JMfocus = float2( focusJ, -JMcusp.y * focusAdjust * focusDistanceGain );\n    // float2 achromaticIntercept = float2(JMfocus.x - (((JMinput.x-JMfocus.x) / (JMinput.y-JMfocus.y))*JMfocus.y), 0.0f);\n\n    float2 achromaticIntercept = float2(JMinput.x, 0.0f);\n\n    // to reduce the number of expensive boundary finding iterations needed\n    // we taking an educated guess at a good starting step size\n    // based on how far the sample is either above or below the gamut cusp\n    float cuspToTipRatio;\n    if( JMinput.x > JMcusp.x )\n    \{\n      cuspToTipRatio = (JMinput.x - JMcusp.x) / (limitJmax - JMcusp.x);\n    \}\n    else\n    \{\n      cuspToTipRatio = (JMcusp.x - JMinput.x) / JMcusp.x;\n    \}\n\n    float startStepSize = lerp(JMcusp.y / 3.0f, 0.1f, cuspToTipRatio);\n\n    float2 JMboundary = findBoundary(JMinput, JMfocus,  inputJMh.z, refWhite, d65White, XYZ_to_RGB_limit, smoothCusps, iterativeGamutCompressorIterations, startStepSize);\n    float normFact = 1.0f / max(0.0001f, length(JMboundary - achromaticIntercept));\n    float v = length(JMinput-achromaticIntercept) * normFact;\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(float3(inputJMh.x,JMboundary.y,inputJMh.z));\n\n    float vCompressed = compressPowerP(v, interpolatedCompressionFuncParams.x, lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, distanceGainCalcJ / limitJmax), interpolatedCompressionFuncParams.w, invert);\n    float2 JMcompressed = 0.0f;\n\n    // hack to stop nan values after compression\n\n    if (JMinput.y != 0.0f)\n    \{\n      JMcompressed = achromaticIntercept + normalize(JMinput-achromaticIntercept)*vCompressed/normFact;\n    \}\n    else\n    \{\n      JMcompressed = JMinput;\n    \}\n    if (JMinput.x > limitJmax)\n    \{\n      JMcompressed = float2(limitJmax,0.0f);\n    \}\n    // JMcompressed.x = lerp(JMcompressed.x,inputJMh.x,compressionMix);\n    // JMcompressed.y = lerp(JMcompressed.y,inputJMh.y,compressionMix);\n    if (diagnosticMode == 5)\n    \{\n      return float3(JMfocus.x, JMfocus.y, normFact);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, inputJMh.z);\n    \}\n  \}\n\n  // find the JM coordinates of the smoothed boundary of the limiting gamut in ZCAM at the hue slice 'h' \n  // by searching along the line defined by 'JMSource' and 'JMFocus'\n  // the function will search outwards from where the line intersects the achromatic axis with a staring incement of 'startStepSize'\n  // once the boundary has been crossed it will search in the opposite direction with half the step size\n  // and will repeat this as as many times as is set by the 'precision' paramter\n  float2 findBoundary(float2 JMSource, float2 JMFocus, float h, float3 XYZw, float3 XYZd65, float3x3 XYZ_to_RGB, float smoothing, int precision, float startStepSize )\n  \{\n\n    float2 achromaticIntercept = float2(JMFocus.x - (((JMSource.x-JMFocus.x) / (JMSource.y-JMFocus.y))*JMFocus.y), 0.0f);\n\n    if( achromaticIntercept.x <= 0.0f || achromaticIntercept.x >= limitJmax )\n    \{\n       return achromaticIntercept;\n    \}\n\n\n    float stepSize = startStepSize;\n    float2 unitVector = normalize(achromaticIntercept - JMFocus);\n    float2 JMtest = achromaticIntercept;\n    int searchOutwards = 1;\n\n    for( int i = 0; i < precision; ++i )\n    \{\n\n      for( int k = 0; k < 30; ++k )\n      \{\n        JMtest = JMtest + unitVector * stepSize;\n        int inside = isInsideCube( vector_dot(XYZ_to_RGB, JMh_to_XYZ( float3(JMtest.x, JMtest.y, h), XYZw, XYZd65, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid) / referenceLuminance ), boundaryRGB, smoothing);\n\n        if( searchOutwards )\n        \{\n          if( JMtest.x < 0.0f || JMtest.x > limitJmax || JMtest.y > limitMmax || !inside )\n          \{\n            searchOutwards = 0;\n            stepSize = -fabs(stepSize) / 2.0f;\n            break;\n          \}\n        \}\n        else\n        \{\n          if( JMtest.y < 0.0f || inside )\n          \{\n            searchOutwards = 1;\n            stepSize = fabs(stepSize) / 2.0f;\n            break;\n          \}\n        \}\n      \}\n    \}\n\n\n    float2 JMboundary = float2( clamp(JMtest.x, 0.0f, limitJmax), clamp(JMtest.y, 0.0f, limitMmax) );\n    // float2 JMboundary = float2(JMtest.x, JMtest.y);\n    return JMboundary;\n  \}\n\n    // check if the 3D point 'v' is inside a cube with the dimensions cubeSize x cubeSize x cubeSize \n  // the 'smoothing' parameter rounds off the edges and corners of the cube with the exception of the 0,0,0 and cubeSize x cubeSize x cubeSize corners\n  // a smoothing value of 0.0 applies no smoothing and 1.0 the maximum amount (smoothing values > 1.0 result in undefined behavior )\n  int isInsideCube( float3 v, float cubeSize, float smoothing)\n  \{\n    float3 normv = v / cubeSize;\n\n    float minv = min(normv.x, min(normv.y, normv.z));\n    float maxv = max(normv.x, max(normv.y, normv.z));\n\n    if( smoothing <= 0.0f )\n    \{\n      // when not smoothing we can use a much simpler test\n      if(minv < 0.0f || maxv > 1.0f)\n      \{\n        return 0;\n      \}\n\n      return 1;\n    \}\n\n    float3 clamped = normv;\n\n    float radius = smoothing/2.0f;\n\n    radius = clamp(radius*maxv*(1.0f-minv), 0.0f, radius);\n\n    clamped.x = clamp(normv.x, radius, 1.0f-radius);\n    clamped.y = clamp(normv.y, radius, 1.0f-radius);\n    clamped.z = clamp(normv.z, radius, 1.0f-radius);\n\n\n    if( length(normv - clamped ) > radius)\n    \{\n      return 0;\n    \}\n\n    return 1;\n  \}\n\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Chroma compression constants\n    nJ_exp = 1.0f / (0.59f * 1.9272);    // 1.0 / (c * z)\n//    toe = max(0.00005f, 0.0003f - 0.001f * log10(daniele_n / daniele_n_r));\n    toe = max(0.0002f, 0.0005f - 0.001f * log10(daniele_n / daniele_n_r));\n\n    // In-gamut compression scaling for HDR/SDR appearance match\n    el = max(1.5f, 2.3f - 0.3f * log10(daniele_n / daniele_n_r)); \n    ef = max(0.4f, 1.0f - 0.55f * log10(daniele_n / daniele_n_r)); \n    ccParams.x = chromaCParams.x + 0.35f * log10(daniele_n / daniele_n_r);\n    ccParams.y = chromaCParams.y + 13.0f * log10(daniele_n / daniele_n_r);\n    ccParams.z = chromaCParams.z;\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // M Max data generated via an external Nukescript at a J value of 100\n    float LocusLimitMTable_data\[]=\n    \{\n      244.8230133, 245.4952393, 246.4431458, 247.1381531, 247.2368927, 246.8459778, 245.7083588, 244.2591095, 242.5463409, 240.4208374, 238.0180511, 235.4039917, 233.010849, 230.4004669, 227.8723602, 225.2279968, 222.7197876, 214.8562622, 206.1778564, 198.0664215, 190.9799347, 184.005127, 177.7472992, 172.2332611, 166.6447754, 161.64534, 156.9872284, 152.6203003, 148.3236084, 144.2987976, 140.8540192, 137.4315033, 134.3281555, 131.2306366, 128.3477631, 125.8098145, 123.1305542, 120.5120163, 118.3302231, 116.127861, 114.0526428, 112.1633072, 110.2943344, 108.4250336, 106.711853, 105.188797, 103.6860809, 102.2319641, 100.8348923, 99.51873779, 98.26163483, 97.04810333, 95.90451813, 94.84623718, 93.86389923, 92.9352951, 92.03639984, 91.15013885, 90.27630615, 89.43255615, 88.63536072, 87.8986969, 87.23329163, 86.63896942, 86.09989166, 85.60071564, 85.12715912, 84.66781616, 84.21458435, 83.76491547, 83.30849457, 82.86478424, 82.46378326, 82.11483002, 81.82078552, 81.58016968, 81.37005615, 81.18525696, 81.01979065, 80.86772156, 80.72546387, 80.59381104, 80.48122406, 80.40287018, 80.33755493, 80.30010986, 80.28891754, 80.28807831, 80.33933258, 80.44513702, 80.57379913, 80.71469879, 80.86810303, 81.03874207, 81.23072052, 81.44044495, 81.6555481, 81.901474, 82.20778656, 82.67211151, 83.1408844, 83.62628174, 84.0898056, 84.53721619, 84.99518585, 85.49137878, 86.03423309, 86.58794403, 87.16802979, 87.72124481, 88.51965332, 89.35781097, 90.16739655, 90.94639587, 91.75927734, 92.65882111, 93.6033783, 94.64561462, 95.68405914, 96.84765625, 97.98625183, 99.09587097, 100.2806396, 101.5832748, 103.0694122, 104.6378632, 106.2420197, 107.8503952, 109.5214844, 111.3000031, 113.1901169, 115.1414337, 117.1432114, 119.3193054, 121.7141724, 124.2319031, 126.4584961, 128.9876556, 131.6906891, 134.7160034, 137.8343048, 140.7224121, 143.7820892, 147.23909, 150.6812439, 154.0381317, 157.1765747, 160.5133972, 164.2957306, 168.1366272, 171.8247986, 175.4206543, 179.2828827, 182.0374146, 185.0783844, 188.2106171, 190.9611206, 193.3639221, 195.5132294, 197.58255, 199.4234161, 201.3786011, 203.1474609, 205.016037, 206.6236725, 208.1813812, 209.8205719, 211.2774353, 212.8192749, 214.4571686, 215.6442261, 216.4818726, 217.1617279, 217.7372131, 218.2023926, 218.4073486, 218.4278564, 217.6643677, 216.4666748, 215.1212463, 213.8158264, 212.5012817, 210.8331757, 208.8956146, 206.9006958, 204.9239197, 203.0310059, 201.2084045, 199.3484344, 197.3464355, 195.217453, 193.0449677, 190.9578705, 188.9528656, 187.0009918, 185.0068817, 182.9402924, 180.8367767, 178.7057037, 176.5325165, 174.445282, 172.4908905, 170.5744934, 168.5490723, 166.459259, 164.4333649, 162.5092621, 160.4579468, 158.491806, 156.6880035, 155.0045624, 153.295166, 151.4545441, 149.5910492, 147.7821808, 146.4078522, 144.8022614, 143.2662506, 141.8236542, 140.5029602, 139.225174, 137.8959045, 136.4792175, 135.0780334, 133.7389374, 132.7613525, 131.6787109, 130.6356354, 129.64328, 128.7269897, 127.8450623, 126.9439697, 126.0015182, 125.0760727, 124.1718826, 123.4704056, 122.8062363, 122.1408768, 121.501358, 120.9004822, 120.3225555, 119.7514191, 119.2011871, 118.7055511, 118.2950592, 117.9416199, 117.5793762, 117.2029953, 116.8356552, 116.4874039, 116.1693954, 115.9030762, 115.6935577, 115.5213852, 115.3659363, 115.2032318, 115.0445251, 114.9317932, 114.8815384, 114.8605118, 114.8510284, 114.8482819, 114.848465, 114.8521805, 114.8999329, 115.0081787, 115.1483612, 115.2983322, 115.511528, 115.7195816, 115.9448853, 116.2098999, 116.5264893, 116.8126144, 117.1579666, 117.5379944, 117.9048004, 118.3263168, 118.8006821, 119.2988586, 119.8310318, 120.3776703, 121.0383987, 121.6810684, 122.4489899, 123.207077, 124.071022, 124.9082108, 125.74823, 126.6865311, 127.4425888, 127.8552094, 128.1067963, 128.3630676, 128.6606598, 128.9203491, 129.2632141, 129.708252, 130.1131287, 130.5647278, 130.9923553, 131.5979462, 132.2623444, 132.8651428, 133.4651947, 134.1470337, 134.8683624, 135.683609, 136.6136017, 137.5203552, 138.3826599, 139.2931976, 140.2762299, 141.2150574, 142.3930054, 143.7060547, 145.0472565, 146.3404083, 147.6144257, 148.9406586, 150.3545532, 151.8509674, 153.4246826, 155.0567017, 156.7265472, 158.4546509, 160.2428131, 162.1348267, 164.1415863, 166.2302551, 168.4024506, 170.5583649, 172.6457672, 174.9460449, 177.2792664, 179.6472473, 182.1867218, 184.5882721, 187.3068848, 189.8807373, 192.5116577, 195.5551453, 198.5196381, 201.3429413, 203.941452, 206.8439484, 209.5599213, 212.4866943, 215.0750885, 217.929306, 220.6668701, 223.364151, 226.2115479, 228.9524536, 231.5583954, 234.405304, 237.0275879, 239.5091705, 242.0047455, 242.0177155\n    \};\n\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the reach primaries matrix\n    if( primariesReach == 0 )\n    \{\n        XYZ_to_RGB_reach.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesReach == 1 )\n    \{\n        XYZ_to_RGB_reach.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesReach == 2 )\n    \{\n        XYZ_to_RGB_reach.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesReach == 3 )\n    \{\n        XYZ_to_RGB_reach.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesReach == 4 )\n    \{\n        XYZ_to_RGB_reach.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesReach == 5 )\n    \{\n        XYZ_to_RGB_reach.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n        XYZ_to_RGB_reach.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_reach = XYZ_to_RGB_reach.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    XYZ_to_AP1.setArray(XYZ_to_AP1_ACES_matrix_data);\n    AP1_to_XYZ = XYZ_to_AP1.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n\n    // LocusLimitMTable = LocusLimitMTable_data;\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      LocusLimitMTable\[i] = LocusLimitMTable_data\[i];\n    \}\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    // limitMmax (assumed to coincide with one of the RGBCMY corners of the limitRGB cube)\n    float3 gamutCornersTable\[6];\n    gamutCornersTable\[0] = limit_RGB_to_JMh(float3(1.0f, 0.0f, 0.0f));\n    gamutCornersTable\[1] = limit_RGB_to_JMh(float3(1.0f, 1.0f, 0.0f));\n    gamutCornersTable\[2] = limit_RGB_to_JMh(float3(0.0f, 1.0f, 0.0f));\n    gamutCornersTable\[3] = limit_RGB_to_JMh(float3(0.0f, 1.0f, 1.0f));\n    gamutCornersTable\[4] = limit_RGB_to_JMh(float3(0.0f, 0.0f, 1.0f));\n    gamutCornersTable\[5] = limit_RGB_to_JMh(float3(1.0f, 0.0f, 1.0f));\n\n    limitMmax = 0.0f;\n    for( int i = 0; i < 6; ++i )\n    \{\n        limitMmax = max(limitMmax, gamutCornersTable\[i].y);\n    \}\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n  // Cusp table for limiting gamut\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // Cusp table for limiting reach gamut, values at a J of 100\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      int precisionMultiplier = 1;  // high values will up the number of samples\n      for( int M = 0; M < 500; ++M )\n      \{\n        float sampleM = float(M);\n        float3 newLimitRGB = JMh_to_reach_RGB(float3(limitJmax,sampleM,i));\n        // gamutCuspTableReach\[i] = float(M);\n        // break;\n        if (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f)\n        \{\n          gamutCuspTableReach\[i].x = sampleM;\n          break;\n        \}\n      \}\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n    \n    // Cusp table for AP1 gamut\n    \{\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsortedAP1\[i] = AP1_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsortedAP1\[i].z <  gamutCuspTableUnsortedAP1\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTableAP1\[i] = gamutCuspTableUnsortedAP1\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n  \}\n\n\n\n\n\}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    // SampleType(extra) sourceExtra = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    // float3 extraRGB(sourceExtra.x, sourceExtra.y, sourceExtra.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      if( invert )\n      \{\n        diagnostic =  JMh_to_input_RGB(srcRGB);\n      \}\n      else\n      \{\n        diagnostic =  JMh;\n      \}\n\n    \}\n    else if ( diagnosticMode == 2 )\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n/*\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    else if (diagnosticMode == 14)\n    \{\n      // output gamut cusp\n      diagnostic = float3(cuspFromTable(srcRGB.z).x, cuspFromTable(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 15)\n    \{\n      // output AP1 cusp\n      diagnostic = float3(cuspFromTableAP1(srcRGB.z).x, cuspFromTableAP1(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 16)\n    \{\n      // output Locus cusp\n      diagnostic = float3(cuspFromTableLocus(srcRGB.z).x, cuspFromTableLocus(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 17)\n    \{\n      // output Locus boundry\n      diagnostic = getLocusBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 18)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0  );\n    \}\n    else if (diagnosticMode == 19)\n    \{\n      // output Reach boundry\n      diagnostic = getReachBoundry(srcRGB);\n    \}\n*/\n\n\n\n    // extra modes to allow for easier breakout of the order of events.\n    // modes starting with 100\n/*\n    else if (diagnosticMode == 100)\n    \{\n      // output input as luminanceXYZ\n      diagnostic = input_RGB_to_JMh(srcRGB);\n    \}\n\n    else if (diagnosticMode == 101)\n    \{\n      // convert luminanceXYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n\n    else if (diagnosticMode == 102)\n    \{\n      // JMh to tonemappedJMh\n    //   diagnostic = forwardTonescale(srcRGB, extraRGB);\n      diagnostic = forwardTonescale(srcRGB);\n    \}\n\n    else if (diagnosticMode == 103)\n    \{\n      // JMh to gamut compressed JMh\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    else if (diagnosticMode == 104)\n    \{\n      // JMh to luminance XYZ\n      diagnostic = JMh_to_XYZ( srcRGB, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n\n    else if (diagnosticMode == 105)\n    \{\n      // luminance XYZ to luminanceRGB\n      diagnostic = JMh_to_output_RGB(srcRGB);\n    \}\n\n    else if (diagnosticMode == 106)\n    \{\n      // luminanceRGB to output RGB\n      diagnostic = luminanceToEncoding3( encodingOut, srcRGB);\n    \}\n*/\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_applyInGamutExpansion {{parent.applyInGamutExpansion}}
  DRT_CAM_Kernel_applyInGamutCompression {{parent.applyInGamutCompression}}
  DRT_CAM_Kernel_monochrome {{parent.monochrome}}
  DRT_CAM_Kernel_chromaCParams {{parent.chromaCompress.x} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_primariesReach {{parent.primaries_reach}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_Reachcompressmode {{parent.reachCompressMode}}
  DRT_CAM_Kernel_Locuscompressmode {{parent.BlinkScript1_DRT_CAM_Kernel_Locuscompressmode}}
  DRT_CAM_Kernel_iterativeGamutCompressor {{parent.iterativeGamutCompressor}}
  DRT_CAM_Kernel_iterativeGamutCompressorIterations 10
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -199
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
