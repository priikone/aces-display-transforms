set cut_paste_input [stack 0]
version 13.1 v3
push $cut_paste_input
Group {
 name OkishDRT_v1
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]"
 note_font "Bitstream Vera Sans"
 selected true
 xpos 330
 ypos 87
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" ""}}
 primaries_in AP1-ACES
 addUserKnob {4 cat_type l "CAT Type" t "the chromatic adaptation transform to use for converting between white points" M {None "XYZ Scaling" Bradford CAT02 "" ""}}
 cat_type CAT02
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {41 Okish_DRT_v1_Kernel_mmTonescaleMode l "Apply MM Tonescale" T BlinkScript1.Okish_DRT_v1_Kernel_mmTonescaleMode}
 addUserKnob {13 ssts_luminance l "TS luminance" t "min, mid & peak luminance values in Cd/sqm as parameters for the TS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {41 Okish_DRT_v1_Kernel_useLightness l "Use Lightness metric" t "Use Lightness (L) intead of mid(RGB) norm" T BlinkScript1.Okish_DRT_v1_Kernel_useLightness}
 addUserKnob {41 Okish_DRT_v1_Kernel_applyMacAdamLimit l "Apply MacAdam Limit" T BlinkScript1.Okish_DRT_v1_Kernel_applyMacAdamLimit}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 apply_gamut_compression l "apply gamut mapping " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {41 Okish_DRT_v1_Kernel_applyGamutApproximation l "apply gamut approximation" T BlinkScript1.Okish_DRT_v1_Kernel_applyGamutApproximation}
 addUserKnob {4 primaries_limit l primaries t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI ""}}
 primaries_limit sRGB/Rec.709-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.5
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "gamut cusp (0) to SSTS mid (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "the distance from the achromatic axis of the focal point of the compression where 0.0 is at the achromatic axis and 1.0 the distance of the gamut cusp at the given hue but on the opposite side of the achomatic axis" R 0 2}
 focus_distance 0.5
 addUserKnob {26 focus_depth_label l " " -STARTLINE T "achromatic (0) to cusp opposite (1)"}
 addUserKnob {13 compression_params l compression t "the threshold, limit and power parameters for the PowerP compression function\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.75 1.2 1.2}
 addUserKnob {26 compression_params_label l " " -STARTLINE T "threshold / limit / power"}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps 0.1
 addUserKnob {3 solve_precision l "solve precision" t "the number of iterations used for finding the gamut boundary using the interval bisection method"}
 solve_precision 10
 addUserKnob {3 inverse_solver_iterations l "inverse solver iterations" t "the number of iterations used for finding the original J & M values when applying the inverse gamut compression"}
 inverse_solver_iterations 10
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 ""}}
 encoding_out BT.1886
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" ""}}
 primaries_out sRGB/Rec.709-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {26 direction_div l Direction +INVISIBLE}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +INVISIBLE +STARTLINE}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -294
 }
 BlinkScript {
  kernelSourceFile OkishDRT_v1.blink
  recompileCount 1400
  ProgramGroup 1
  KernelDescription "2 \"Okish_DRT_v1_Kernel\" iterate pixelWise fa61884e699fc11a3a20a9019faae2c375d69ab80670c4d2c4c2c25ad0d963d7 2 \"src\" Read Point \"dst\" Write Point 40 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"discountIlluminant\" Bool 1 AA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"useLightness\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"applyGamutApproximation\" Bool 1 AA== \"applyMacAdamLimit\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"boundarySolvePrecision\" Int 1 AAAAAA== \"inverseSolverIterations\" Int 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"invert\" Bool 1 AA== \"mmTonescaleMode\" Bool 1 AA== \"Lp\" Float 1 AAAAAA== \"su\" Float 1 AAAAAA== \"c0\" Float 1 AAAAAA== \"cs\" Float 1 AAAAAA== \"c1\" Float 1 AAAAAA== \"p\" Float 1 AAAAAA== \"w1\" Float 1 AAAAAA== \"s1\" Float 1 AAAAAA== \"ex\" Float 1 AAAAAA== \"eb\" Float 1 AAAAAA== \"e0\" Float 1 AAAAAA== \"s0\" Float 1 AAAAAA== \"fl\" Float 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"desat_offset\" Float 1 AAAAAA== \"chroma_scale\" Float 1 AAAAAA== 40 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"catType\" 1 1 \"discountIlluminant\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"useLightness\" 1 1 \"sstsLuminance\" 3 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"applyGamutApproximation\" 1 1 \"applyMacAdamLimit\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 3 1 \"smoothCusps\" 1 1 \"boundarySolvePrecision\" 1 1 \"inverseSolverIterations\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"invert\" 1 1 \"mmTonescaleMode\" 1 1 \"Lp\" 1 1 \"su\" 1 1 \"c0\" 1 1 \"cs\" 1 1 \"c1\" 1 1 \"p\" 1 1 \"w1\" 1 1 \"s1\" 1 1 \"ex\" 1 1 \"eb\" 1 1 \"e0\" 1 1 \"s0\" 1 1 \"fl\" 1 1 \"mmScaleFactor\" 1 1 \"desat_offset\" 1 1 \"chroma_scale\" 1 1 34 \"HALF_MIN\" Float 1 1 AAAAAA== \"HALF_MAX\" Float 1 1 AAAAAA== \"cat_adaptDegree\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_M1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_M2\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"M_to_RGBish\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitLmax\" Float 1 1 AAAAAA== \"limitCmax\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"focusDistanceClamped\" Float 1 1 AAAAAA== \"gamutCornersTable\" Float 3 6 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel Okish_DRT_v1_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Chomatic Adaptation Transform to Use\n    // 0: None\n    // 1: XYZ Scaling\n    // 2: Bradford\n    // 3: CAT02\n    // 4: Zhai2018 (two-step)\n    int catType;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n\n    //\n    // Tonescale Parameters\n    //\n\n    // Use lightness instead of mid(rgb) norm\n    bool useLightness;\n\n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n    bool applyGamutApproximation;\n\n    // MacAdam limit\n    bool applyMacAdamLimit;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // the distance of the compression focal point\n    // from the achromatic axis\n    // normalised to the distance of the gamut cusp\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / Limit / Power\n    float3 compressionFuncParams;\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    // When solving for the target gamut boundary\n    // how many search interval halving steps to perform\n    int boundarySolvePrecision;\n\n    // Number of iterations to converge on the uncompressed J value \n    // Because of the compression focus point changes depending on the J value of the uncompressed sample\n    // we cannot perfectly invert it since the original J value has now been changed by the forward compression\n    // we can converge on a reasonable approximation of the original J value by iterating the inverse compression\n    // although this is quite an expensive operation\n    int inverseSolverIterations;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n\n    // Tonescale select\n    bool mmTonescaleMode;\n    // Tonescale parameters\n    float Lp;\n    float su;\n    float c0;\n    float cs;\n    float c1;\n    float p;\n    float w1;\n    float s1;\n    float ex;\n    float eb;\n    float e0;\n    float s0;\n    float fl;\n    float mmScaleFactor;\n\n    float desat_offset;\n    float chroma_scale;\n\n  local:\n\n    // constants\n    float HALF_MIN;\n    float HALF_MAX;\n\n    // CAT vars\n    float cat_adaptDegree;\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // matrix vars\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    float3x3 XYZ_to_LMS_M1;\n    float3x3 XYZ_to_LMS_M2;\n    float3x3 M_to_RGBish;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 refWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitLmax;\n\n    // the maximum colorfulness value of the limiting gamut\n    float limitCmax;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp LCh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given hue (h) value \n    // one must search the table entries for the mathcing entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and LCh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest LCh.h value\n    // both tables need to be declared here since tempoary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n\n    // local version of the public focusDistance parameter\n    // this one will be clamped to a value > 0.0\n    float focusDistanceClamped;\n\n    float3 gamutCornersTable\[6];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially retured -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n      return pow(base, exponent); \n    \}\n  \}\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // apply chromatic adaptation transform to 'XYZ' from 'XYZ_ws' to 'XYZ_wd' white points\n  // 'type' selects the cone fundamentals matrix\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type)\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n  // check if the 3D point 'v' is inside a cube with the dimensions cubeSize x cubeSize x cubeSize \n  // the 'smoothing' parameter rounds off the edges and corners of the cube with the exception of the 0,0,0 and cubeSize x cubeSize x cubeSize corners\n  // a smoothing value of 0.0 applies no smoothing and 1.0 the maximum amount (smoothing values > 1.0 result in undefined behavior )\n  int isInsideCube( float3 v, float cubeSize, float smoothing)\n  \{\n    float3 normv = v / cubeSize;\n\n    float minv = min(normv.x, min(normv.y, normv.z));\n    float maxv = max(normv.x, max(normv.y, normv.z));\n\n    if( smoothing <= 0.0f )\n    \{\n      // when not smoothing we can use a much simpler test\n      if(minv < 0.0f || maxv > 1.0f)\n      \{\n        return 0;\n      \}\n\n      return 1;\n    \}\n\n    float3 clamped = normv;\n\n    float radius = smoothing/2.0f;\n\n    radius = clamp(radius*maxv*(1.0f-minv), 0.0f, radius);\n\n    clamped.x = clamp(normv.x, radius, 1.0f-radius);\n    clamped.y = clamp(normv.y, radius, 1.0f-radius);\n    clamped.z = clamp(normv.z, radius, 1.0f-radius);\n\n    if( length(normv - clamped ) > radius)\n    \{\n      return 0;\n    \}\n\n    return 1;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  float3 XYZ_to_Oklab_LMS(float3 XYZ)\n  \{\n    float3 LMS = vector_dot(XYZ_to_LMS_M1, XYZ);\n    LMS.x = spow(LMS.x, 1.0f / 3.0f);\n    LMS.y = spow(LMS.y, 1.0f / 3.0f);\n    LMS.z = spow(LMS.z, 1.0f / 3.0f);\n    return LMS;\n  \}\n\n  float3 Oklab_LMS_to_XYZ(float3 LMS)\n  \{\n    LMS = LMS * LMS * LMS;\n    return vector_dot(XYZ_to_LMS_M1.invert(), LMS);\n  \}\n\n  float3 Oklab_LMS_to_Lab(float3 LMS)\n  \{\n    return vector_dot(XYZ_to_LMS_M2, LMS);\n  \}\n\n  float3 Lab_to_Oklab_LMS(float3 lab)\n  \{\n    return vector_dot(XYZ_to_LMS_M2.invert(), lab);\n  \}\n\n  float3 Lab_to_LCh(float3 lab)\n  \{\n    float3 lch;\n    lch.x = lab.x;\n    lch.y = sqrt(lab.y * lab.y + lab.z * lab.z);\n    lch.z = fmod(degrees(atan2(lab.z, lab.y)) + 360.0f, 360.0f);\n    return lch;\n  \}\n\n  float3 LCh_to_Lab(float3 lch)\n  \{\n    float3 lab;\n    float h = radians(lch.z);\n    lab.x = lch.x;\n    lab.y = lch.y * cos(h);\n    lab.z = lch.y * sin(h);\n    return lab;\n  \}\n\n  float3 limit_RGB_to_LMS(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB * referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 LMS = XYZ_to_Oklab_LMS(XYZ);\n    return LMS;\n  \}\n\n  float3 limit_RGB_to_LCh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB * referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 LMS = XYZ_to_Oklab_LMS(XYZ);\n    return Lab_to_LCh(Oklab_LMS_to_Lab(LMS));\n  \}\n\n  // convert RGB values in the input colorspace to XYZ D65\n  float3 input_RGB_to_XYZ(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAX range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAX, HALF_MAX);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3(encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n\n    return apply_CAT(luminanceXYZ, inWhite, d65White, catType);\n  \}\n\n  // convert XYZ D65 to RGB values in the output colorspace\n  float3 XYZ_to_output_RGB(float3 XYZ)\n  \{\n    float3 luminanceXYZ = apply_CAT(XYZ, d65White, refWhite, catType);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if (clampOutput)\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n\n    return outputRGB;\n  \}\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n  // retrieve the LC coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n\n  // find the LC coordinates of the smoothed boundary of the limiting gamaut in at the hue slice 'h' \n  // by searching along the line defined by 'LCSource' and 'LCfocus'\n  // the function will search outwards from where the line intersects the achromatic axis with a staring incement of 'startStepSize'\n  // once the boundary has been crossed it will search in the opposite direction with half the step size\n  // and will repeat this as as many times as is set by the 'precision' paramter\n  float2 findBoundary(float2 LCSource, float2 LCfocus, float h, float3 XYZw, float3 XYZd65, float3x3 XYZ_to_RGB, float smoothing, int precision, float startStepSize )\n  \{\n    float2 achromaticIntercept = float2(LCfocus.x - (((LCSource.x-LCfocus.x) / (LCSource.y-LCfocus.y))*LCfocus.y), 0.0f);\n\n    if( achromaticIntercept.x <= 0.0f || achromaticIntercept.x >= limitLmax )\n    \{\n       return achromaticIntercept;\n    \}\n\n    float stepSize = startStepSize;\n    float2 unitVector = normalize(achromaticIntercept - LCfocus);\n    float2 LCtest = achromaticIntercept;\n    int searchOutwards = 1;\n\n    for( int i = 0; i < precision; ++i )\n    \{\n\n//      while( 1 )\n      for( int j = 0; j < precision; ++j )\n      \{\n        LCtest = LCtest + unitVector * stepSize;\n        float3 XYZ = Oklab_LMS_to_XYZ(Lab_to_Oklab_LMS(LCh_to_Lab(float3(LCtest.x, LCtest.y, h))));\n        XYZ = apply_CAT(XYZ, XYZd65, XYZw, catType);\n        int inside = isInsideCube( vector_dot(XYZ_to_RGB, XYZ / referenceLuminance ), boundaryRGB, smoothing);\n\n        if( searchOutwards )\n        \{\n          if( LCtest.x < 0.0f || LCtest.x > limitLmax || LCtest.y > limitCmax || !inside )\n          \{\n            searchOutwards = 0;\n            stepSize = -fabs(stepSize) / 2.0f;\n            break;\n          \}\n        \}\n        else\n        \{\n          if( LCtest.y < 0.0f || inside )\n          \{\n            searchOutwards = 1;\n            stepSize = fabs(stepSize) / 2.0f;\n            break;\n          \}\n        \}\n      \}\n    \}\n\n    float2 LCboundary = float2( clamp(LCtest.x, 0.0f, limitLmax), clamp(LCtest.y, 0.0f, limitCmax) );\n\n    return LCboundary;\n  \}\n\n  void init()\n  \{\n    HALF_MIN = 0.0000000596046448f;\n    HALF_MAX = 65504.0f;\n\n    if( discountIlluminant )\n    \{\n      cat_adaptDegree = 1.0f;\n    \}\n    else\n    \{\n      float viewingConditionsCoeff = 1.0f;\n\n      if( viewingConditions == 0 )\n      \{\n        viewingConditionsCoeff = 0.8f;\n      \}\n      else if( viewingConditions == 1 )\n      \{\n        viewingConditionsCoeff = 0.9f;\n      \}\n      else if( viewingConditions == 2 )\n      \{\n        viewingConditionsCoeff = 1.0f;\n      \}\n    \}\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_Oklab_M1_data\[]=\{\n        0.8189330101, 0.3618667424, -0.1288597137,\n        0.0329845436, 0.9293118715, 0.0361456387,\n        0.0482003018, 0.2643662691, 0.6338517070 \};\n\n    float XYZ_to_LMS_Oklab_M2_data\[]=\{\n        0.2104542553, 0.7936177850, -0.0040720468,\n        1.9779984951, -2.4285922050, 0.4505937099,\n        0.0259040371, 0.7827717662, -0.8086757660 \};\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    XYZ_to_LMS_M1.setArray(XYZ_to_LMS_Oklab_M1_data);\n    XYZ_to_LMS_M2.setArray(XYZ_to_LMS_Oklab_M2_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n\n    //\n    // solving the RGB cusp from LCh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to LCh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_LCh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n\n    // limitLmax (asumed to match limitRGB white)\n    limitLmax = limit_RGB_to_LCh(float3(1.0f)).x;\n\n    // limitCmax (asumed to coincide with one of the RGBCMY corners of the limitRGB cube)\n    gamutCornersTable\[0] = limit_RGB_to_LCh(float3(1.0f, 0.0f, 0.0f));\n    gamutCornersTable\[1] = limit_RGB_to_LCh(float3(1.0f, 1.0f, 0.0f));\n    gamutCornersTable\[2] = limit_RGB_to_LCh(float3(0.0f, 1.0f, 0.0f));\n    gamutCornersTable\[3] = limit_RGB_to_LCh(float3(0.0f, 1.0f, 1.0f));\n    gamutCornersTable\[4] = limit_RGB_to_LCh(float3(0.0f, 0.0f, 1.0f));\n    gamutCornersTable\[5] = limit_RGB_to_LCh(float3(1.0f, 0.0f, 1.0f));\n\n    limitCmax = 0.0f;\n    for( int i = 0; i < 6; ++i )\n    \{\n      limitCmax = max(limitCmax, gamutCornersTable\[i].y);\n    \}\n\n    // ensure positive, non-zero focus depth\n    // to avoid the gamut boundary search vector becoming zero for achromatic colors\n    // which will cause the boundary search loop to continue forever and the node to hang\n    focusDistanceClamped = max(0.01f, focusDistance);\n\n    // MacAdam limit approximation\n    // Approximated using: https://colab.research.google.com/drive/1-f0AM9fKA3lOojV8H-730afjyMWC26EX?usp=sharing\n    float MacAdam_bt2020\[] =\n    \{\n       2.26775149f, -1.43293879f,  0.1651873f,\n      -0.98535505f,  2.1260072f, -0.14065215f,\n      -0.02501605f, -0.26349465f,  1.2885107f\n    \};\n    float MacAdam_p3d65\[] =\n    \{\n       2.0763642 , -1.20049804,  0.12413384,\n      -0.88022845,  1.96011755, -0.0798891,\n      -0.01253181, -0.27758506,  1.29011688\n    \};\n    float MacAdam_bt709\[] =\n    \{\n       1.95630914, -1.06350026,  0.10719112,\n      -0.8793777 ,  1.92864324, -0.04926554,\n       0.0061942 , -0.29897333,  1.29277913\n    \};\n\n    if (primariesLimit == 2)\n      \{\n        M_to_RGBish.setArray(MacAdam_bt709);\n      \}\n    else if (primariesLimit == 3)\n      \{\n        M_to_RGBish.setArray(MacAdam_bt2020);\n      \}\n    else if (primariesLimit == 4)\n      \{\n        M_to_RGBish.setArray(MacAdam_p3d65);\n      \}\n    else\n      \{\n        M_to_RGBish.setArray(identity_matrix_data);\n      \}\n  \}\n\n  float3 compressGamut( float3 inputLCh, int invert, float distanceGainCalcJ )\n  \{\n    if (!applyGamutCompression)\n    \{\n      return inputLCh;\n    \}\n\n    float3 XYZ = apply_CAT(refWhite * sstsLuminance.y, refWhite, d65White, catType);\n    float sstsMidJ = Oklab_LMS_to_Lab(XYZ_to_Oklab_LMS(XYZ)).x;\n    float2 LCinput = float2(inputLCh.x, inputLCh.y);\n    float2 LCcusp = cuspFromTable( inputLCh.z);\n\n    float focusL = lerp(LCcusp.x, sstsMidJ, cuspMidBlend);\n\n    float focusDistanceGain = 1.0f;\n\n    if( distanceGainCalcJ > focusL )\n    \{\n      focusDistanceGain = (limitLmax - focusL) / max(0.0001f, (limitLmax - min(limitLmax, distanceGainCalcJ)));\n    \}\n    else\n    \{\n      focusDistanceGain = (focusL) / max(0.0001f, distanceGainCalcJ);\n    \}\n\n    float2 LCfocus = float2( focusL, -LCcusp.y*focusDistanceClamped*focusDistanceGain );\n    float2 vecToFocus = (LCfocus - LCinput);\n    float2 achromaticIntercept = float2(LCfocus.x - (((LCinput.x-LCfocus.x) / (LCinput.y-LCfocus.y))*LCfocus.y), 0.0f);\n\n    // to reduce the number of expensive boundary finding iterations needed\n    // we taking an educated guess at a good starting step size\n    // based on how far the sample is either above or below the gamut cusp\n    float cuspToTipRatio;\n    if( LCinput.x > LCcusp.x )\n    \{\n      cuspToTipRatio = (LCinput.x - LCcusp.x) / (limitLmax - LCcusp.x);\n    \}\n    else\n    \{\n      cuspToTipRatio = (LCcusp.x - LCinput.x) / (LCcusp.x);\n    \}\n\n    float startStepSize = lerp(LCcusp.y / 3.0f, 0.1f, cuspToTipRatio);\n    float2 LCboundary = findBoundary(LCinput, LCfocus,  inputLCh.z, refWhite, d65White, XYZ_to_RGB_limit, smoothCusps, boundarySolvePrecision, startStepSize);\n    float normFact = 1.0f / max(0.0001f, length(LCboundary - achromaticIntercept));\n    float v = length(LCinput-achromaticIntercept) * normFact;\n    float vCompressed = compressPowerP(v, compressionFuncParams.x, compressionFuncParams.y, compressionFuncParams.z, invert);\n    float2 LCcompressed = 0.0f;\n    // hack to stop nan values after compression\n    if (LCinput.y != 0.0f)\n    \{\n      LCcompressed = achromaticIntercept + normalize(LCinput-achromaticIntercept)*vCompressed/normFact;\n    \}\n    else\n    \{\n      LCcompressed = LCinput;\n    \}\n    return float3(LCcompressed.x, LCcompressed.y, inputLCh.z);\n  \}\n\n  // apply the forward gamut compression to the limiting primaries\n  float3 compressGamutForward(float3 LCh)\n  \{\n    float3 LChcompressed = compressGamut( LCh, 0, LCh.x );\n    return LChcompressed;\n  \}\n\n  float2 approximateShape(float3 lab, float C)\n  \{\n    float a = lab.y / C;\n    float b = lab.z / C;\n\n    float a2 = 2.0f * a * b;\n    float b2 = a * a - b * b;\n    float a3 = 3.0f * a - 4.0f * a * a * a;\n    float b3 = -3.0f * b + 4.0f * b * b * b;\n\n    if (primariesLimit == 2)\n      \{\n        return float2(\n          1.45502420e+00 + -7.65623334e-02*a +  2.26234241e-01*b +  6.25596210e-02*a2 +  3.16995726e-02*b2 + 4.46107711e-02*a3 +  3.49876286e-02*b3,\n          2.69987106e-01 + 1.69987106e-02*a +   1.00116716e-03*b +  1.02594717e-02*a2 + -6.08142494e-04*b2 + 2.29845394e-03*a3 + 2.13300284e-03*b3\n        );\n      \}\n    else if (primariesLimit == 3)\n      \{\n        // TODO\n        return float2(\n          1.45502420e+00 + -7.65623334e-02*a +  2.26234241e-01*b +  6.25596210e-02*a2 +  3.16995726e-02*b2 + 4.46107711e-02*a3 +  3.49876286e-02*b3,\n          2.69987106e-01 + 1.69987106e-02*a +   1.00116716e-03*b +  1.02594717e-02*a2 + -6.08142494e-04*b2 + 2.29845394e-03*a3 + 2.13300284e-03*b3\n        );\n      \}\n    else if (primariesLimit == 4)\n      \{\n        // TODO\n        return float2(\n          1.45502420e+00 + -7.65623334e-02*a +  2.26234241e-01*b +  6.25596210e-02*a2 +  3.16995726e-02*b2 + 4.46107711e-02*a3 +  3.49876286e-02*b3,\n          2.69987106e-01 + 1.69987106e-02*a +   1.00116716e-03*b +  1.02594717e-02*a2 + -6.08142494e-04*b2 + 2.29845394e-03*a3 + 2.13300284e-03*b3\n        );\n      \}\n    else\n      \{\n        return float2(a, b);\n      \}\n  \}\n\n  float3 approximateGamutMap(float3 LMS)\n  \{\n    float I = getMidAndPurity(LMS).x;\n    float3 lab = Oklab_LMS_to_Lab(LMS);\n    float C = Lab_to_LCh(lab).y;\n    float2 ST = approximateShape(lab, C);\n    float i_max = max(LMS.x, max(LMS.y, LMS.z));\n//    float C_smooth = 1.0f / ((ST.x / I) + (ST.y / (1.0f - I)));\n    float C_smooth = 1.0f / ((ST.x / I) + (ST.y / I));\n//    float C_smooth = 1.8f;\n\n    return (LMS - I) / sqrt(C * C / C_smooth / C_smooth + 1.0f) + I;\n  \}\n\n  float forwardMmTonescale(float x)\n  \{\n    float tc = 0.0f;\n\n    if (x < 0.18) \{\n      tc = cs * spow(x, c0);\n    \} else \{\n      tc = c0 * (x - 0.18) + 0.18;\n    \}\n\n    float ts = s1 * spow((tc / (s0 + tc)), p);\n    float tf = ts * ts / (ts + fl);\n\n    return tf;\n  \}\n\n  // Derivative according to Mathematica FullSimplify\[D\[forwardMmTonescale\[x], x]]\n  float d_forwardMmTonescale(float x)\n  \{\n    float tc1, tf2, pp;\n\n    if (x < 0.18) \{\n      tc1 = cs * spow(x, c0);\n      pp = 2.0f * p;\n    \} else \{\n      tc1 = c0 * (x - 0.18) + 0.18;\n      pp = 2.0f * p - 1.0f;\n    \}\n\n    float tc = tc1 / (tc1 + s0);\n    float ts1 = s1 * spow(tc, p) + (2.0f * fl);\n    float ts2 = spow(s1 * spow(tc, p) + fl, 2.0f);\n    float tf1 = (c0 * p * s0 * s1 * s1 * spow(tc, pp)) * ts1;\n    \n    if (x < 0.18) \{\n      tf2 = x * (tc1 + s0) * ts2;\n    \} else \{\n      tf2 = spow(tc1 + s0, 2.0f) * ts2;\n    \}\n\n    if (tf2 == 0.0f)\n      tf2 = 0.0000000001f;\n    float tf = tf1 / tf2;\n\n    return tf;\n  \}\n\n  // Find mid(RGB) and purity\n  float2 getMidAndPurity(float3 LMS)\n  \{\n    if (applyMacAdamLimit)\n      LMS = vector_dot(M_to_RGBish, LMS);\n\n    float i_min = min(max(0.0, LMS.x), min(max(0.0, LMS.y), max(0.0, LMS.z)));\n    float i_max = max(LMS.x, max(LMS.y, LMS.z));\n\n    // Mid point and purity (saturation)\n    float m = 0.5 * (i_max + i_min);\n    float s = i_max - i_min;\n\n    // Smoothing\n    if (s == 0.0f)\n      s = 0.0000000001f;\n    float3 y = (LMS - m) / s;\n    m = m + dot(y * y * y, float3(1.0f / 3.0f, 1.0f / 3.0f, 1.0f / 3.0f)) * s;\n    s = sqrt(dot(LMS - m, LMS - m) / 2.0f);\n\n    return float2(m, s);\n  \}\n\n  float getIntensity(float3 LMS)\n  \{\n    float2 MP = getMidAndPurity(LMS);\n    float I = MP.x + (1.0f - desat_offset) * MP.y;\n    return I;\n  \}\n\n  float3 extractChroma(float3 LMS, float I, float linearI)\n  \{\n    if (I == 0.0f)\n      I = 0.000000001f;\n    return ((LMS / I) * linearI) - linearI;\n  \}\n\n  float3 forwardTonescale(float3 LMS, float I)\n  \{\n    if (!mmTonescaleMode)\n      return LMS;\n\n    float linearI = spow(I, 3) / referenceLuminance;\n    float3 chroma = extractChroma(LMS, I, linearI);\n\n    float TS = forwardMmTonescale(linearI) * mmScaleFactor;\n    if (TS == 0.0f)\n      TS = 0.000000001f;\n    float3 outLMS = (1.0f + chroma_scale * chroma *\n                     (d_forwardMmTonescale(linearI) * mmScaleFactor) / TS);\n\n    outLMS *= spow(TS, 1.0f / 3.0f);\n\n    return outLMS;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB, lab;\n    float3 LMS = XYZ_to_Oklab_LMS(input_RGB_to_XYZ(srcRGB));\n    float I;\n\n    I = getIntensity(LMS);\n    if (useLightness) \{\n      lab = Oklab_LMS_to_Lab(LMS);\n      I = lab.x;\n    \}\n\n    LMS = forwardTonescale(LMS, I);\n\n    if (applyGamutCompression) \{\n      if (applyGamutApproximation) \{\n        LMS = approximateGamutMap(LMS);\n      \} else \{\n        float3 LCh = Lab_to_LCh(Oklab_LMS_to_Lab(LMS));\n        LCh = compressGamutForward(LCh);\n        LMS = Lab_to_Oklab_LMS(LCh_to_Lab(LCh));\n      \}\n    \}\n    dstRGB = XYZ_to_output_RGB(Oklab_LMS_to_XYZ(LMS));\n\n    dst() = float4(dstRGB.x, dstRGB.y, dstRGB.z, source.w);\n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu 0}}
  rebuild ""
  Okish_DRT_v1_Kernel_encodingIn {{parent.encoding_in}}
  Okish_DRT_v1_Kernel_primariesIn {{parent.primaries_in}}
  Okish_DRT_v1_Kernel_catType {{parent.cat_type}}
  Okish_DRT_v1_Kernel_discountIlluminant {{parent.discount_illuminant}}
  Okish_DRT_v1_Kernel_referenceLuminance {{parent.reference_luminance}}
  Okish_DRT_v1_Kernel_backgroundLuminance {{parent.background_luminance}}
  Okish_DRT_v1_Kernel_viewingConditions {{parent.viewing_conditions}}
  Okish_DRT_v1_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  Okish_DRT_v1_Kernel_primariesLimit {{parent.primaries_limit}}
  Okish_DRT_v1_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  Okish_DRT_v1_Kernel_applyMacAdamLimit true
  Okish_DRT_v1_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  Okish_DRT_v1_Kernel_focusDistance {{parent.focus_distance}}
  Okish_DRT_v1_Kernel_compressionFuncParams {{parent.compression_params.x} {parent.compression_params.y} {parent.compression_params.z}}
  Okish_DRT_v1_Kernel_smoothCusps {{parent.smooth_cusps}}
  Okish_DRT_v1_Kernel_boundarySolvePrecision {{parent.solve_precision}}
  Okish_DRT_v1_Kernel_inverseSolverIterations {{parent.inverse_solver_iterations}}
  Okish_DRT_v1_Kernel_encodingOut {{parent.encoding_out}}
  Okish_DRT_v1_Kernel_primariesOut {{parent.primaries_out}}
  Okish_DRT_v1_Kernel_clampOutput {{parent.clamp_output}}
  Okish_DRT_v1_Kernel_invert {{parent.invert}}
  Okish_DRT_v1_Kernel_mmTonescaleMode true
  Okish_DRT_v1_Kernel_Lp {{parent.ssts_luminance.z}}
  Okish_DRT_v1_Kernel_su 2
  Okish_DRT_v1_Kernel_c0 1.2
  Okish_DRT_v1_Kernel_cs {{0.18**(1-Okish_DRT_v1_Kernel_c0)}}
  Okish_DRT_v1_Kernel_c1 1.1
  Okish_DRT_v1_Kernel_p {{Okish_DRT_v1_Kernel_c1*(0.9+0.05*Okish_DRT_v1_Kernel_su)}}
  Okish_DRT_v1_Kernel_w1 {{(0.595*Okish_DRT_v1_Kernel_Lp/10000)**0.931+1.037}}
  Okish_DRT_v1_Kernel_s1 {{Okish_DRT_v1_Kernel_w1*Okish_DRT_v1_Kernel_Lp/100}}
  Okish_DRT_v1_Kernel_ex -0.26
  Okish_DRT_v1_Kernel_eb 0.08
  Okish_DRT_v1_Kernel_e0 {{2**(Okish_DRT_v1_Kernel_ex+Okish_DRT_v1_Kernel_eb*log(Okish_DRT_v1_Kernel_s1)/log(2))}}
  Okish_DRT_v1_Kernel_s0 {{(Okish_DRT_v1_Kernel_s1/Okish_DRT_v1_Kernel_e0)**(1/Okish_DRT_v1_Kernel_c1)}}
  Okish_DRT_v1_Kernel_fl 0.01
  Okish_DRT_v1_Kernel_mmScaleFactor 100
  Okish_DRT_v1_Kernel_desat_offset 1
  Okish_DRT_v1_Kernel_chroma_scale 1
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -221
 }
 Output {
  name Output1
  xpos -908
  ypos -128
 }
end_group
